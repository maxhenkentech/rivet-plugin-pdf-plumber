'use strict';

var uuid = require('uuid');
var v1Api = require('../api/v1-api.js');
var runRequest = require('../models/run-request.js');
var stepRun = require('./step-run.js');
var utils = require('./utils.js');
var init = require('./init.js');

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class PipelineRun {
    constructor({ pipeline, context, }) {
        this.id = uuid.v4();
        this.pipeline = pipeline;
        this.stepRuns = [];
        this.context = context;
    }
    getPipeline() {
        return this.pipeline;
    }
    getId() {
        return this.id;
    }
    getContext() {
        return this.context;
    }
    updateContext(updatedContext) {
        this.context = Object.assign(Object.assign({}, this.context), updatedContext);
        return this.context;
    }
    addStepRunNode(stepRun) {
        return __awaiter(this, void 0, void 0, function* () {
            this.stepRuns.push(stepRun);
        });
    }
    /**
     * Creates a checkpoint by recording a `StepRun` instance with execution metadata and pushes it to `this.stepRuns`.
     * If no prior `StepRun` instances exist, the elapsed time is set to 0 and the start and end times are set to the
     * current timestamp. If it is empty, elapsed time is set to 0 and start time and end time are set to the current
     * timestamp.
     *
     * @param {PRStepRunType & { inputs: any; outputs: any; }} step The information about the step to checkpoint.
     * This includes the inputs and outputs of the step, as well as optional provider, invocation and modelParams metadata.
     *
     * @example
     * const stepInfo = {
     *   providerName: 'MyProvider',
     *   invocation: 'doSomething',
     *   inputs: { x: 10, y: 20 },
     *   outputs: { result: 30 }
     * };
     * checkpoint(stepInfo);
     *
     * @returns {void} The function does not return anything.
     *
     * @throws {Error} If the `StepRun` constructor or any other operations throw an error, it will be propagated.
     */
    checkpoint(step) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const lastElement = this.stepRuns[this.stepRuns.length - 1];
        if (lastElement) {
            const { endTime: stepStartTime } = lastElement;
            const elapsedTime = new Date().getTime() - new Date(stepStartTime).getTime();
            const endTimeNew = new Date().toISOString();
            this.stepRuns.push(new stepRun.StepRun((_a = step.provider) !== null && _a !== void 0 ? _a : "undeclared", (_b = step.invocation) !== null && _b !== void 0 ? _b : "undeclared", elapsedTime, stepStartTime, endTimeNew, step.inputs, (_c = step.modelParams) !== null && _c !== void 0 ? _c : {}, step.outputs, (_d = step.context) !== null && _d !== void 0 ? _d : {}));
        }
        else {
            const elapsedTime = 0;
            const startAndEndTime = new Date().toISOString();
            this.stepRuns.push(new stepRun.StepRun((_e = step.provider) !== null && _e !== void 0 ? _e : "undeclared", (_f = step.invocation) !== null && _f !== void 0 ? _f : "undeclared", elapsedTime, startAndEndTime, startAndEndTime, step.inputs, (_g = step.modelParams) !== null && _g !== void 0 ? _g : {}, step.outputs, (_h = step.context) !== null && _h !== void 0 ? _h : {}));
        }
    }
    /**
     * Asynchronously measures the execution time of a function.
     *
     * @template F Function type that extends (...args: any[]) => any
     * @param {F} func The function to be measured.
     * @param {Parameters<F>} inputs The parameters to be passed to the function.
     * @param {Omit<PRStepRunType, "inputs" | "outputs">} [stepInfo] Optional metadata for the function execution.
     * @returns {Promise<ReturnType<F>>} Returns a promise that resolves to the return type of the function.
     *
     * @example
     * async function foo(n: number) {
     *   return n * 2;
     * }
     * const result = await measure(foo, [2]); // result will be 4
     *
     * The function also records a `StepRun` instance with execution metadata and pushes it to `this.stepRuns`.
     * The recorded `StepRun` includes information such as the elapsed time, start and end time,
     * resolved inputs, and model parameters if provided.
     */
    measure(func, inputs, stepInfo) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const startTime = Date.now();
            const returnValue = yield func(...inputs);
            const paramNames = utils.getParamNames(func);
            const resolvedInputs = utils.zip(paramNames, inputs).reduce((acc, current) => {
                const [key, value] = current;
                acc[key] = value;
                return acc;
            }, {});
            // Our server only accepts outputs as an object.
            let modifiedOuput = returnValue;
            if (typeof returnValue !== "object") {
                modifiedOuput = { value: returnValue };
            }
            const endTime = Date.now();
            const elapsedTime = Math.floor(endTime - startTime);
            this.stepRuns.push(new stepRun.StepRun((_a = stepInfo === null || stepInfo === void 0 ? void 0 : stepInfo.provider) !== null && _a !== void 0 ? _a : "undeclared", (_b = stepInfo === null || stepInfo === void 0 ? void 0 : stepInfo.invocation) !== null && _b !== void 0 ? _b : "undeclared", elapsedTime, new Date(startTime).toISOString(), new Date(endTime).toISOString(), resolvedInputs, (_c = stepInfo === null || stepInfo === void 0 ? void 0 : stepInfo.modelParams) !== null && _c !== void 0 ? _c : {}, modifiedOuput, (_d = stepInfo === null || stepInfo === void 0 ? void 0 : stepInfo.context) !== null && _d !== void 0 ? _d : {}));
            return returnValue;
        });
    }
    submit({ waitForServer } = { waitForServer: false }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const testCounter = utils.getTestCounter();
            if (testCounter > 0) {
                const data = {
                    pipelineRunId: this.id,
                };
                return data;
            }
            const api = new v1Api.V1Api(this.pipeline.config);
            this.pipeline.logInfo("Submitting PipelineRun to Gentrace");
            let mergedMetadata = {};
            const updatedStepRuns = this.stepRuns.map(({ provider: providerName, elapsedTime, startTime, endTime, invocation, modelParams, inputs, outputs, context: stepRunContext, }) => {
                var _a;
                let _b = (_a = this.context) !== null && _a !== void 0 ? _a : {}, { metadata: thisContextMetadata, previousRunId: _prPreviousRunId } = _b, restThisContext = __rest(_b, ["metadata", "previousRunId"]);
                let _c = stepRunContext !== null && stepRunContext !== void 0 ? stepRunContext : {}, { metadata: stepRunContextMetadata, previousRunId: _srPreviousRunId } = _c, restStepRunContext = __rest(_c, ["metadata", "previousRunId"]);
                // Merge metadata
                mergedMetadata = Object.assign(Object.assign(Object.assign({}, mergedMetadata), thisContextMetadata), stepRunContextMetadata);
                return {
                    providerName,
                    elapsedTime,
                    startTime,
                    endTime,
                    invocation,
                    modelParams,
                    inputs,
                    outputs,
                    context: Object.assign(Object.assign({}, restThisContext), restStepRunContext),
                };
            });
            const submission = api.v1RunPost({
                id: this.id,
                slug: this.pipeline.slug,
                metadata: mergedMetadata,
                previousRunId: (_a = this.context) === null || _a === void 0 ? void 0 : _a.previousRunId,
                collectionMethod: runRequest.RunRequestCollectionMethodEnum.Runner,
                stepRuns: updatedStepRuns,
            });
            if (!waitForServer) {
                init.globalRequestBuffer[this.id] = submission;
                submission
                    .catch((e) => {
                    this.pipeline.logWarn(e);
                })
                    .then(() => {
                    this.pipeline.logInfo("Successfully submitted PipelineRun to Gentrace");
                })
                    .finally(() => {
                    delete init.globalRequestBuffer[this.id];
                });
                const data = {
                    pipelineRunId: this.id,
                };
                return data;
            }
            try {
                const pipelinePostResponse = yield submission;
                this.pipeline.logInfo("Successfully submitted PipelineRun to Gentrace");
                return pipelinePostResponse.data;
            }
            catch (e) {
                this.pipeline.logWarn(e);
                throw e;
            }
        });
    }
}

exports.PipelineRun = PipelineRun;
//# sourceMappingURL=pipeline-run.js.map
