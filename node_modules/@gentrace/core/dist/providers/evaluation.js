'use strict';

var init = require('./init.js');
var utils = require('./utils.js');

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/**
 * Retrieves test cases for a given pipeline ID from the Gentrace API
 * @async
 * @param {string} pipelineSlug - The pipeline slug
 * @throws {Error} Throws an error if the SDK is not initialized. Call init() first.
 * @returns {Promise<Array<TestCase>>} A Promise that resolves with an array of test cases.
 */
const getTestCases = (pipelineSlug) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (!init.globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    let pipelineId = pipelineSlug;
    if (!isUUID(pipelineSlug)) {
        const allPipelines = yield getPipelines();
        const matchingPipeline = allPipelines.find((pipeline) => pipeline.slug === pipelineSlug);
        if (!matchingPipeline) {
            throw new Error(`Could not find the specified pipeline (${pipelineSlug})`);
        }
        pipelineId = matchingPipeline.id;
    }
    const response = yield init.globalGentraceApi.v1TestCaseGet(pipelineId);
    const testCases = (_a = response.data.testCases) !== null && _a !== void 0 ? _a : [];
    return testCases;
});
function isTestCaseSingle(response) {
    return response.caseId !== undefined;
}
/**
 * Creates a single test case for a given pipeline ID from the Gentrace API
 *
 * @async
 * @param {CreateSingleTestCase} payload - New test case payload
 * @throws {Error} Throws an error if the SDK is not initialized. Call init() first.
 * @returns {Promise<string>} A Promise that resolves to the created case ID
 */
const createTestCase = (payload) => __awaiter(void 0, void 0, void 0, function* () {
    if (!init.globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const { pipelineSlug } = payload;
    if (!isUUID(pipelineSlug)) {
        const allPipelines = yield getPipelines();
        const matchingPipeline = allPipelines.find((pipeline) => pipeline.slug === pipelineSlug);
        if (!matchingPipeline) {
            throw new Error(`Could not find the specified pipeline (${pipelineSlug})`);
        }
        matchingPipeline.id;
    }
    const response = yield init.globalGentraceApi.v1TestCasePost(payload);
    const data = response.data;
    if (!isTestCaseSingle(data)) {
        throw new Error("Expected a single test case to be created.");
    }
    return data.caseId;
});
/**
 * Creates multiple test cases for a given pipeline ID from the Gentrace API
 *
 * @async
 * @param {CreateMultipleTestCases} payload - New test case payloads
 * @throws {Error} Throws an error if the SDK is not initialized. Call init() first.
 * @returns {Promise<stringl>} A Promise that resolves to the number of test cases successfully created
 */
const createTestCases = (payload) => __awaiter(void 0, void 0, void 0, function* () {
    if (!init.globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const { pipelineSlug } = payload;
    if (!isUUID(pipelineSlug)) {
        const allPipelines = yield getPipelines();
        const matchingPipeline = allPipelines.find((pipeline) => pipeline.slug === pipelineSlug);
        if (!matchingPipeline) {
            throw new Error(`Could not find the specified pipeline (${pipelineSlug})`);
        }
        matchingPipeline.id;
    }
    const response = yield init.globalGentraceApi.v1TestCasePost(payload);
    const data = response.data;
    if (isTestCaseSingle(data)) {
        throw new Error("Expected multiple test cases to be created.");
    }
    return data.creationCount;
});
const updateTestCase = (payload) => __awaiter(void 0, void 0, void 0, function* () {
    if (!init.globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const { id } = payload;
    if (!isUUID(id)) {
        throw new Error("Expected a valid test case ID.");
    }
    const response = yield init.globalGentraceApi.v1TestCasePatch(payload);
    const data = response.data;
    return data.caseId;
});
const constructSubmissionPayload = (pipelineId, testRuns, context) => {
    const body = {
        pipelineId,
        testRuns,
    };
    // Will be overwritten if GENTRACE_RESULT_NAME is specified
    if (init.GENTRACE_RUN_NAME) {
        body.name = init.GENTRACE_RUN_NAME;
    }
    if (init.GENTRACE_RESULT_NAME) {
        body.name = init.GENTRACE_RESULT_NAME;
    }
    if (context === null || context === void 0 ? void 0 : context.metadata) {
        body.metadata = context.metadata;
    }
    if (init.GENTRACE_BRANCH || utils.getProcessEnv("GENTRACE_BRANCH")) {
        body.branch =
            init.GENTRACE_BRANCH.length > 0
                ? init.GENTRACE_BRANCH
                : utils.getProcessEnv("GENTRACE_BRANCH");
    }
    if (init.GENTRACE_COMMIT || utils.getProcessEnv("GENTRACE_COMMIT")) {
        body.commit =
            init.GENTRACE_COMMIT.length > 0
                ? init.GENTRACE_COMMIT
                : utils.getProcessEnv("GENTRACE_COMMIT");
    }
    body.collectionMethod = "runner";
    return body;
};
function isUUID(str) {
    const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;
    return uuidPattern.test(str);
}
/**
 * Submits test results by creating TestResult objects from given test cases and corresponding outputs.
 * To use a Gentrace runner to capture intermediate steps, use {@link runTest} instead.
 *
 * @async
 * @function
 * @param {string} pipelineSlug - The slug of the pipeline
 * @param {TestCase[]} testCases - An array of TestCase objects.
 * @param {string[]} outputs - An array of outputs corresponding to each TestCase.
 *
 * @throws {Error} Will throw an error if the Gentrace API key is not initialized. Also, will throw an error if the number of test cases
 *  does not match the number of outputs.
 *
 * @returns {Promise<TestRunPost200Response>} The response data from the Gentrace API's testRunPost method.
 */
const submitTestResult = (pipelineSlug, testCases, outputsList, context) => __awaiter(void 0, void 0, void 0, function* () {
    if (!init.globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    if (testCases.length !== outputsList.length) {
        throw new Error("The number of test cases must be equal to the number of outputs.");
    }
    const testRuns = testCases.map((testCase, index) => {
        const run = {
            caseId: testCase.id,
            inputs: testCase.inputs,
            outputs: outputsList[index],
        };
        return run;
    });
    const body = {
        pipelineSlug,
        testRuns: testRuns,
    };
    // Will be overwritten if GENTRACE_RESULT_NAME is specified
    if (init.GENTRACE_RUN_NAME) {
        body.name = init.GENTRACE_RUN_NAME;
    }
    if (init.GENTRACE_RESULT_NAME) {
        body.name = init.GENTRACE_RESULT_NAME;
    }
    if (init.GENTRACE_BRANCH || utils.getProcessEnv("GENTRACE_BRANCH")) {
        body.branch =
            init.GENTRACE_BRANCH.length > 0
                ? init.GENTRACE_BRANCH
                : utils.getProcessEnv("GENTRACE_BRANCH");
    }
    if (init.GENTRACE_COMMIT || utils.getProcessEnv("GENTRACE_COMMIT")) {
        body.commit =
            init.GENTRACE_COMMIT.length > 0
                ? init.GENTRACE_COMMIT
                : utils.getProcessEnv("GENTRACE_COMMIT");
    }
    if (context === null || context === void 0 ? void 0 : context.metadata) {
        body.metadata = context.metadata;
    }
    const response = yield init.globalGentraceApi.v1TestResultSimplePost(body);
    return response.data;
});
/**
 * Retrieves pipelines from the Gentrace API.
 * @async
 * @param {PipelineParams} [params] - Optional parameters to filter the pipelines.
 * @returns {Promise<Array<Pipeline>>} - A promise that resolves to an array of pipelines.
 * @throws {Error} - Throws an error if the Gentrace API key is not initialized.
 */
const getPipelines = (params) => __awaiter(void 0, void 0, void 0, function* () {
    if (!init.globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const label = (params !== null && params !== void 0 ? params : {}).label;
    const slug = (params !== null && params !== void 0 ? params : {}).slug;
    const parameters = [label, slug];
    const response = yield init.globalGentraceApi.v1PipelinesGet(...parameters);
    return response.data.pipelines;
});
/**
 * Retrieves a test result from the Gentrace API.
 * @async
 * @param {string} resultId - The ID of the test result.
 * @returns {Promise<ExpandedTestResult>} - A promise that resolves to the test result.
 * @throws {Error} - Throws an error if the Gentrace API key is not initialized.
 */
const getTestResult = (resultId) => __awaiter(void 0, void 0, void 0, function* () {
    if (!init.globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const response = yield init.globalGentraceApi.v1TestResultIdGet(resultId);
    const testResult = response.data;
    return testResult;
});
/**
 * Retrieves the status of a test result from the Gentrace API.
 * @async
 * @param {string} resultId - The ID of the test result.
 * @returns {Promise<StatusInfo>} - A promise that resolves to the test result.
 * @throws {Error} - Throws an error if the Gentrace API key is not initialized.
 */
const getTestResultStatus = (resultId) => __awaiter(void 0, void 0, void 0, function* () {
    if (!init.globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const response = yield init.globalGentraceApi.v1TestResultStatusGet(resultId);
    const statusInfo = response.data;
    return statusInfo;
});
/**
 * Retrieves test results from the Gentrace API.
 * @async
 * @param {string} pipelineSlug - The slug of the pipeline.
 * @returns {Promise<Array<TestResult>>} - A promise that resolves to the test results.
 * @throws {Error} - Throws an error if the Gentrace API key is not initialized.
 */
const getTestResults = (pipelineSlug) => __awaiter(void 0, void 0, void 0, function* () {
    if (!init.globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const response = yield init.globalGentraceApi.v1TestResultGet(pipelineSlug);
    const testResults = response.data.testResults;
    return testResults;
});
/**
 * Runs a test for a specific pipeline.
 *
 * @param {string} pipelineSlug - The slug of the pipeline.
 * @param {(testCase: TestCase) => Promise<PipelineRun>} handler - The handler function that runs the test case and returns a promise with a PipelineRun.
 * @returns {Promise<TestRun>} - A promise that resolves to the test result.
 * @throws {Error} - Throws an error if the specified pipeline cannot be found.
 */
const runTest = (pipelineSlug, handler, context) => __awaiter(void 0, void 0, void 0, function* () {
    utils.incrementTestCounter();
    try {
        const allPipelines = yield getPipelines();
        const matchingPipeline = allPipelines.find((pipeline) => pipeline.slug === pipelineSlug);
        if (!matchingPipeline) {
            throw new Error(`Could not find the specified pipeline (${pipelineSlug})`);
        }
        const testCases = yield getTestCases(matchingPipeline.id);
        const testRuns = [];
        for (const testCase of testCases) {
            const [, pipelineRun] = yield handler(testCase);
            let mergedMetadata = {};
            const updatedStepRuns = pipelineRun.stepRuns.map((stepRun) => {
                var _a, _b;
                let _c = (_a = pipelineRun.context) !== null && _a !== void 0 ? _a : {}, { metadata: thisContextMetadata, previousRunId: _prPreviousRunId } = _c, restThisContext = __rest(_c, ["metadata", "previousRunId"]);
                let _d = (_b = stepRun.context) !== null && _b !== void 0 ? _b : {}, { metadata: stepRunContextMetadata, previousRunId: _srPreviousRunId } = _d, restStepRunContext = __rest(_d, ["metadata", "previousRunId"]);
                // Merge metadata
                mergedMetadata = Object.assign(Object.assign(Object.assign({}, mergedMetadata), thisContextMetadata), stepRunContextMetadata);
                return {
                    modelParams: stepRun.modelParams,
                    invocation: stepRun.invocation,
                    inputs: stepRun.inputs,
                    outputs: stepRun.outputs,
                    providerName: stepRun.provider,
                    elapsedTime: stepRun.elapsedTime,
                    startTime: stepRun.startTime,
                    endTime: stepRun.endTime,
                    context: Object.assign(Object.assign({}, restThisContext), restStepRunContext),
                };
            });
            const testRun = {
                caseId: testCase.id,
                metadata: mergedMetadata,
                stepRuns: updatedStepRuns,
            };
            if (pipelineRun.getId()) {
                testRun.id = pipelineRun.getId();
            }
            testRuns.push(testRun);
        }
        if (!init.globalGentraceApi) {
            throw new Error("Gentrace API key not initialized. Call init() first.");
        }
        const body = constructSubmissionPayload(matchingPipeline.id, testRuns, context);
        const response = yield init.globalGentraceApi.v1TestResultPost(body);
        return response.data;
    }
    catch (e) {
        throw e;
    }
    finally {
        // Imperative that we decrement the test counter regardless of whether the function
        // runs into an error or not.
        utils.decrementTestCounter();
    }
});

exports.constructSubmissionPayload = constructSubmissionPayload;
exports.createTestCase = createTestCase;
exports.createTestCases = createTestCases;
exports.getPipelines = getPipelines;
exports.getTestCases = getTestCases;
exports.getTestResult = getTestResult;
exports.getTestResultStatus = getTestResultStatus;
exports.getTestResults = getTestResults;
exports.runTest = runTest;
exports.submitTestResult = submitTestResult;
exports.updateTestCase = updateTestCase;
//# sourceMappingURL=evaluation.js.map
