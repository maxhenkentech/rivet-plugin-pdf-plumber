"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONDiff = void 0;
const number_js_1 = require("./number.js");
const string_js_1 = require("./string.js");
/**
 * A simple scorer that compares JSON objects, using a customizable comparison method for strings
 * (defaults to Levenshtein) and numbers (defaults to NumericDiff).
 */
const JSONDiff = ({ output, expected, stringScorer = string_js_1.LevenshteinScorer, numberScorer = number_js_1.NumericDiff, }) => __awaiter(void 0, void 0, void 0, function* () {
    return {
        name: "JSONDiff",
        score: yield jsonDiff(output, expected, stringScorer, numberScorer),
    };
});
exports.JSONDiff = JSONDiff;
function jsonDiff(o1, o2, stringScorer, numberScorer) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isObject(o1) && isObject(o2)) {
            if (Object.keys(o1).length == 0 && Object.keys(o2).length == 0) {
                return 1;
            }
            const allKeys = Object.keys(Object.fromEntries(Object.keys(o1)
                .concat(Object.keys(o2))
                .map((k) => [k, true])));
            const baseScores = yield Promise.all(allKeys.map((k) => jsonDiff(o1[k], o2[k], stringScorer, numberScorer)));
            return baseScores.reduce((acc, s) => acc + s, 0) / baseScores.length;
        }
        else if (isArray(o1) && isArray(o2)) {
            if (o1.length === 0 && o2.length === 0) {
                return 1;
            }
            const baseScores = yield Promise.all(Array.from({
                length: Math.min(o1.length, o2.length),
            }).map((_, i) => jsonDiff(o1[i], o2[i], stringScorer, numberScorer)));
            return (baseScores.reduce((acc, s) => acc + s, 0) / Math.max(o1.length, o2.length));
        }
        else if (typeof o1 === "string" && typeof o2 === "string") {
            return (yield stringScorer({ output: o1, expected: o2 })).score;
        }
        else if (typeof o1 === "number" && typeof o2 === "number") {
            return (yield numberScorer({ output: o1, expected: o2 })).score;
        }
        else if ((o1 === null || o1 === undefined) &&
            (o2 === null || o2 === undefined)) {
            return 1;
        }
        else if (o1 === null ||
            o1 === undefined ||
            o2 === null ||
            o2 === undefined) {
            return 0;
        }
        else {
            return (yield stringScorer({
                output: JSON.stringify(o1, replacer),
                expected: JSON.stringify(o2, replacer),
            })).score;
        }
    });
}
function isObject(value) {
    return value instanceof Object && !(value instanceof Array);
}
function isArray(value) {
    return value instanceof Array;
}
// https://gist.github.com/davidfurlong/463a83a33b70a3b6618e97ec9679e490
const replacer = (key, value) => isObject(value)
    ? Object.keys(value)
        .sort()
        .reduce((sorted, key) => {
        sorted[key] = value[key];
        return sorted;
    }, {})
    : value;
