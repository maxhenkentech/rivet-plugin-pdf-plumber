import { type ChartNode, type NodeInputDefinition, type NodeOutputDefinition } from '../NodeBase.js';
import { NodeImpl, type NodeUIData } from '../NodeImpl.js';
import { type ScalarOrArrayDataType } from '../DataValue.js';
import { type Inputs, type Outputs } from '../GraphProcessor.js';
import { type InternalProcessContext } from '../ProcessContext.js';
import { type EditorDefinition, type NodeBodySpec } from '../../index.js';
export type GetGlobalNode = ChartNode<'getGlobal', GetGlobalNodeData>;
export type GetGlobalNodeData = {
    id: string;
    useIdInput: boolean;
    dataType: ScalarOrArrayDataType;
    /**
     * Returns a fn<value> instead of a value, so that the variable is read when nodes need it, rather than when this node executes.
     * The only time you wouldn't want this is to read a global at the start of a subgraph.
     */
    onDemand: boolean;
    /** Wait until the variable is available */
    wait: boolean;
};
export declare class GetGlobalNodeImpl extends NodeImpl<GetGlobalNode> {
    static create(): GetGlobalNode;
    getInputDefinitions(): NodeInputDefinition[];
    getOutputDefinitions(): NodeOutputDefinition[];
    getEditors(): EditorDefinition<GetGlobalNode>[];
    getBody(): string | NodeBodySpec | undefined;
    static getUIData(): NodeUIData;
    process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs>;
}
export declare const getGlobalNode: import("../NodeDefinition.js").NodeDefinition<GetGlobalNode>;
