import {} from '../index.js';
import { coerceType } from '../utils/coerceType.js';
/** A simplified way to listen and stream processor events, including filtering. */
export async function* getProcessorEvents(processor, spec) {
    const previousIndexes = new Map();
    for await (const event of processor.events()) {
        if (event.type === 'partialOutput') {
            if (spec.partialOutputs === true ||
                spec.partialOutputs?.includes(event.node.id) ||
                spec.partialOutputs?.includes(event.node.title)) {
                const currentOutput = coerceType(event.outputs['response'], 'string');
                const delta = currentOutput.slice(previousIndexes.get(event.node.id) ?? 0);
                yield {
                    type: 'partialOutput',
                    nodeId: event.node.id,
                    nodeTitle: event.node.title,
                    delta,
                };
                previousIndexes.set(event.node.id, currentOutput.length);
            }
        }
        else if (event.type === 'done') {
            if (spec.done) {
                yield {
                    type: 'done',
                    graphOutput: event.results,
                };
            }
        }
        else if (event.type === 'error') {
            if (spec.error) {
                yield {
                    type: 'error',
                    error: typeof event.error === 'string' ? event.error : event.error.toString(),
                };
            }
        }
        else if (event.type === 'nodeStart') {
            if (spec.nodeStart === true ||
                spec.nodeStart?.includes(event.node.id) ||
                spec.nodeStart?.includes(event.node.title)) {
                yield {
                    type: 'nodeStart',
                    inputs: event.inputs,
                    nodeId: event.node.id,
                    nodeTitle: event.node.title,
                };
            }
        }
        else if (event.type === 'nodeFinish') {
            if (spec.nodeFinish === true ||
                spec.nodeFinish?.includes(event.node.id) ||
                spec.nodeFinish?.includes(event.node.title)) {
                yield {
                    type: 'nodeFinish',
                    outputs: event.outputs,
                    nodeId: event.node.id,
                    nodeTitle: event.node.title,
                };
            }
        }
    }
}
/**
 * Creates a ReadableStream for processor events, following the Server-Sent Events protocol.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventSource
 *
 * Includes configuration for what events to send to the client, for example you can stream the partial output deltas
 * for specific nodes, and/or the graph output when done.
 */
export function getProcessorSSEStream(processor, 
/** The spec for what you're streaming to the client */
spec) {
    const encoder = new TextEncoder();
    function sendEvent(controller, type, data) {
        const event = `event: ${type}\ndata: ${JSON.stringify(data)}\n\n`;
        controller.enqueue(encoder.encode(event));
    }
    return new ReadableStream({
        async start(controller) {
            try {
                for await (const event of getProcessorEvents(processor, spec)) {
                    sendEvent(controller, event.type, event);
                }
                controller.close();
            }
            catch (err) {
                controller.error(err);
            }
        },
    });
}
export function getSingleNodeStream(processor, nodeIdOrTitle) {
    return new ReadableStream({
        async start(controller) {
            try {
                for await (const event of getProcessorEvents(processor, {
                    partialOutputs: [nodeIdOrTitle],
                    nodeFinish: [nodeIdOrTitle],
                })) {
                    if (event.type === 'partialOutput' && (event.nodeId === nodeIdOrTitle || event.nodeTitle === nodeIdOrTitle)) {
                        controller.enqueue(`data: ${JSON.stringify(event.delta)}\n\n`);
                    }
                    else if (event.type === 'nodeFinish' &&
                        (event.nodeId === nodeIdOrTitle || event.nodeTitle === nodeIdOrTitle)) {
                        controller.close();
                    }
                }
                controller.close();
            }
            catch (err) {
                controller.error(err);
            }
        },
    });
}
