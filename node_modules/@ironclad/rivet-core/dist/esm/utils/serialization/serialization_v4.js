import { mapValues } from 'lodash-es';
import stableStringify from 'safe-stable-stringify';
import * as yaml from 'yaml';
import { doubleCheckProject } from './serializationUtils.js';
import { entries } from '../typeSafety.js';
export function projectV4Deserializer(data) {
    if (typeof data !== 'string') {
        throw new Error('Project v4 deserializer requires a string');
    }
    const serializedProject = yaml.parse(data);
    if (serializedProject.version !== 4) {
        throw new Error('Project v4 deserializer requires a version 4 project');
    }
    const [project, attachedData] = fromSerializedProject(serializedProject.data);
    doubleCheckProject(project);
    return [project, attachedData];
}
export function graphV4Deserializer(data) {
    if (typeof data !== 'string') {
        throw new Error('Graph v4 deserializer requires a string');
    }
    const serializedGraph = yaml.parse(data);
    if (serializedGraph.version !== 4) {
        throw new Error('Graph v4 deserializer requires a version 4 graph');
    }
    return fromSerializedGraph(serializedGraph.data);
}
export function projectV4Serializer(project, attachedData) {
    // Make sure all data is ordered deterministically first
    const stabilized = JSON.parse(stableStringify(toSerializedProject(project, attachedData)));
    const serialized = yaml.stringify({
        version: 4,
        data: stabilized,
    }, null, {
        indent: 2,
    });
    return serialized;
}
export function graphV4Serializer(graph) {
    // Make sure all data is ordered deterministically first
    const stabilized = JSON.parse(stableStringify(toSerializedGraph(graph)));
    const serialized = yaml.stringify({
        version: 4,
        data: stabilized,
    }, null, {
        indent: 2,
    });
    return serialized;
}
function toSerializedProject(project, attachedData) {
    return {
        metadata: project.metadata,
        graphs: mapValues(project.graphs, (graph) => toSerializedGraph(graph)),
        attachedData,
        plugins: project.plugins ?? [],
    };
}
function fromSerializedProject(serializedProject) {
    return [
        {
            metadata: serializedProject.metadata,
            graphs: mapValues(serializedProject.graphs, (graph) => fromSerializedGraph(graph)),
            plugins: serializedProject.plugins ?? [],
        },
        serializedProject.attachedData ?? {},
    ];
}
function toSerializedGraph(graph) {
    const graphMetadata = {
        id: graph.metadata.id,
        name: graph.metadata.name,
        description: graph.metadata.description,
    };
    if (graph.metadata.attachedData) {
        graphMetadata.attachedData = graph.metadata.attachedData;
    }
    return {
        metadata: graphMetadata,
        nodes: graph.nodes.reduce((acc, node) => ({
            ...acc,
            [getGraphNodeKey(node)]: toSerializedNode(node, graph.nodes, graph.connections),
        }), {}),
    };
}
function getGraphNodeKey(node) {
    return `[${node.id}]:${node.type} "${node.title}"`;
}
function deserializeGraphNodeKey(key) {
    const { nodeId, type, title } = key.match(/^\[(?<nodeId>[^\]]+)\]:(?<type>[^\s]+) "(?<title>.*)"$/)?.groups ?? {};
    if (!nodeId || !type || !title) {
        throw new Error(`Invalid graph node key: ${key}`);
    }
    return [nodeId, type, title];
}
function fromSerializedGraph(serializedGraph) {
    const allConnections = [];
    const allNodes = [];
    for (const [serializedNodeInfo, node] of entries(serializedGraph.nodes)) {
        const [chartNode, connections] = fromSerializedNode(node, serializedNodeInfo);
        allNodes.push(chartNode);
        allConnections.push(...connections);
    }
    const metadata = {
        id: serializedGraph.metadata.id,
        name: serializedGraph.metadata.name,
        description: serializedGraph.metadata.description,
    };
    if (serializedGraph.metadata.attachedData) {
        metadata.attachedData = serializedGraph.metadata.attachedData;
    }
    return {
        metadata,
        nodes: allNodes,
        connections: allConnections,
    };
}
function toSerializedNode(node, allNodes, allConnections) {
    const outgoingConnections = allConnections
        .filter((connection) => connection.outputNodeId === node.id)
        .map((connection) => toSerializedConnection(connection, allNodes))
        .sort();
    return {
        description: node.description?.trim() ? node.description : undefined,
        visualData: `${node.visualData.x}/${node.visualData.y}/${node.visualData.width ?? 'null'}/${node.visualData.zIndex ?? 'null'}/${node.visualData.color?.border ?? ''}/${node.visualData.color?.bg ?? ''}`,
        isSplitRun: node.isSplitRun ? true : undefined,
        splitRunMax: node.isSplitRun ? node.splitRunMax : undefined,
        data: Object.keys(node.data ?? {}).length > 0 ? node.data : undefined,
        outgoingConnections: outgoingConnections.length > 0 ? outgoingConnections : undefined,
        variants: (node.variants?.length ?? 0) > 0 ? node.variants : undefined,
        disabled: node.disabled ? true : undefined,
    };
}
function fromSerializedNode(serializedNode, serializedNodeInfo) {
    const [nodeId, type, title] = deserializeGraphNodeKey(serializedNodeInfo);
    const [x, y, width, zIndex, borderColor, bgColor] = serializedNode.visualData.split('/');
    const connections = serializedNode.outgoingConnections?.map((serializedConnection) => fromSerializedConnection(serializedConnection, nodeId)) ?? [];
    const color = borderColor || bgColor ? { border: borderColor, bg: bgColor } : undefined;
    return [
        {
            id: nodeId,
            type,
            title,
            description: serializedNode.description,
            isSplitRun: serializedNode.isSplitRun ?? false,
            splitRunMax: serializedNode.splitRunMax ?? 10,
            isSplitSequential: serializedNode.isSplitSequential ?? false,
            visualData: {
                x: parseFloat(x),
                y: parseFloat(y),
                width: width === 'null' ? undefined : parseFloat(width),
                zIndex: zIndex === 'null' ? undefined : parseFloat(zIndex),
                color,
            },
            data: serializedNode.data ?? {},
            variants: serializedNode.variants ?? [],
            disabled: serializedNode.disabled,
        },
        connections,
    ];
}
function toSerializedConnection(connection, allNodes) {
    return `${connection.outputId}->"${allNodes.find((node) => node.id === connection.inputNodeId)?.title}" ${connection.inputNodeId}/${connection.inputId}`;
}
function fromSerializedConnection(connection, nodeId) {
    const [, outputId, , inputNodeId, inputId] = connection.match(/(.+)->"(.+)" (.+)\/(.+)/);
    return {
        outputId: outputId,
        outputNodeId: nodeId,
        inputId: inputId,
        inputNodeId: inputNodeId,
    };
}
export function datasetV4Serializer(datasets) {
    const dataContainer = {
        datasets,
    };
    const data = JSON.stringify(dataContainer);
    return data;
}
export function datasetV4Deserializer(serializedDatasets) {
    const stringData = serializedDatasets;
    const dataContainer = JSON.parse(stringData);
    if (!dataContainer.datasets) {
        throw new Error('Invalid dataset data');
    }
    return dataContainer.datasets;
}
