import {} from '../index.js';
import { cloneDeep } from 'lodash-es';
export class InMemoryDatasetProvider {
    #datasets;
    constructor(datasets) {
        this.#datasets = datasets;
    }
    async getDatasetMetadata(id) {
        const dataset = this.#datasets.find((d) => d.meta.id === id);
        return dataset?.meta;
    }
    async getDatasetsForProject(projectId) {
        return this.#datasets.map((d) => d.meta);
    }
    async getDatasetData(id) {
        const dataset = this.#datasets.find((d) => d.meta.id === id);
        if (!dataset) {
            return { id, rows: [] };
        }
        return dataset.data;
    }
    async putDatasetRow(id, row) {
        const dataset = this.#datasets.find((d) => d.meta.id === id);
        if (!dataset) {
            throw new Error(`Dataset ${id} not found`);
        }
        const existingRow = dataset.data.rows.find((r) => r.id === row.id);
        if (existingRow) {
            existingRow.data = row.data;
            existingRow.embedding = row.embedding;
            return;
        }
        dataset.data.rows.push(row);
    }
    async putDatasetData(id, data) {
        const dataset = this.#datasets.find((d) => d.meta.id === id);
        if (!dataset) {
            throw new Error(`Dataset ${id} not found`);
        }
        dataset.data = data;
    }
    async putDatasetMetadata(metadata) {
        const matchingDataset = this.#datasets.find((d) => d.meta.id === metadata.id);
        if (matchingDataset) {
            matchingDataset.meta = metadata;
            return;
        }
        this.#datasets.push({
            meta: metadata,
            data: {
                id: metadata.id,
                rows: [],
            },
        });
    }
    async clearDatasetData(id) {
        const dataset = this.#datasets.find((d) => d.meta.id === id);
        if (!dataset) {
            return;
        }
        dataset.data = {
            id,
            rows: [],
        };
    }
    async deleteDataset(id) {
        const index = this.#datasets.findIndex((d) => d.meta.id === id);
        if (index === -1) {
            return;
        }
        this.#datasets.splice(index, 1);
    }
    async knnDatasetRows(datasetId, k, vector) {
        const allRows = await this.getDatasetData(datasetId);
        const sorted = allRows.rows
            .filter((row) => row.embedding != null)
            .map((row) => ({
            row,
            similarity: dotProductSimilarity(vector, row.embedding),
        }))
            .sort((a, b) => b.similarity - a.similarity);
        return sorted.slice(0, k).map((r) => ({ ...r.row, distance: r.similarity }));
    }
    async exportDatasetsForProject(_projectId) {
        // Cloning is safest... but slow
        return cloneDeep(this.#datasets);
    }
}
/** OpenAI embeddings are already normalized, so this is equivalent to cosine similarity */
const dotProductSimilarity = (a, b) => {
    return a.reduce((acc, val, i) => acc + val * b[i], 0);
};
