import { nanoid } from 'nanoid/non-secure';
import {} from '../../../index.js';
import { HfInference, HfInferenceEndpoint } from '@huggingface/inference';
import { dedent } from 'ts-dedent';
import { pluginNodeDefinition } from '../../../model/NodeDefinition.js';
import { getInputOrData } from '../../../utils/inputs.js';
import { coerceType } from '../../../utils/coerceType.js';
export const TextToImageHuggingFaceNodeImpl = {
    create() {
        return {
            id: nanoid(),
            type: 'textToImageHuggingFace',
            data: {
                model: '',
                width: 256,
                height: 256,
                negativePrompt: '',
                guidanceScale: 7,
                numInferenceSteps: 3,
            },
            title: 'Text-to-Image (Hugging Face)',
            visualData: {
                x: 0,
                y: 0,
                width: 300,
            },
        };
    },
    getUIData() {
        return {
            group: ['AI', 'Hugging Face'],
            contextMenuTitle: 'Text-to-Image (Hugging Face)',
            infoBoxTitle: 'Text-to-Image (Hugging Face) Node',
            infoBoxBody: 'Use the Hugging Face API to generate an image from text.',
        };
    },
    getInputDefinitions(data) {
        const inputs = [];
        inputs.push({
            id: 'prompt',
            dataType: 'string',
            title: 'Prompt',
            required: true,
        });
        if (data.useModelInput) {
            inputs.push({
                id: 'model',
                dataType: 'string',
                title: 'Model',
            });
        }
        if (data.useEndpointInput) {
            inputs.push({
                id: 'endpoint',
                dataType: 'string',
                title: 'Endpoint',
            });
        }
        if (data.useWidthInput) {
            inputs.push({
                id: 'width',
                dataType: 'number',
                title: 'Width',
            });
        }
        if (data.useHeightInput) {
            inputs.push({
                id: 'height',
                dataType: 'number',
                title: 'Height',
            });
        }
        if (data.useNegativePromptInput) {
            inputs.push({
                id: 'negativePrompt',
                dataType: 'string',
                title: 'Negative Prompt',
            });
        }
        if (data.useGuidanceScaleInput) {
            inputs.push({
                id: 'guidanceScale',
                dataType: 'number',
                title: 'Guidance Scale',
            });
        }
        if (data.useNumInferenceStepsInput) {
            inputs.push({
                id: 'numInferenceSteps',
                dataType: 'number',
                title: 'Num Inference Steps',
            });
        }
        return inputs;
    },
    getOutputDefinitions() {
        return [
            {
                id: 'output',
                dataType: 'string',
                title: 'Output',
            },
        ];
    },
    getEditors() {
        return [
            {
                type: 'string',
                label: 'Model',
                dataKey: 'model',
                useInputToggleDataKey: 'useModelInput',
            },
            {
                type: 'number',
                label: 'Width',
                dataKey: 'width',
                useInputToggleDataKey: 'useWidthInput',
            },
            {
                type: 'number',
                label: 'Height',
                dataKey: 'height',
                useInputToggleDataKey: 'useHeightInput',
            },
            {
                type: 'string',
                label: 'Negative Prompt',
                dataKey: 'negativePrompt',
                useInputToggleDataKey: 'useNegativePromptInput',
            },
            {
                type: 'number',
                label: 'Guidance Scale',
                dataKey: 'guidanceScale',
                useInputToggleDataKey: 'useGuidanceScaleInput',
                min: 0,
                max: 20,
                step: 1,
            },
            {
                type: 'number',
                label: 'Num Inference Steps',
                dataKey: 'numInferenceSteps',
                useInputToggleDataKey: 'useNumInferenceStepsInput',
                min: 0,
                max: 20,
                step: 1,
            },
        ];
    },
    getBody(data) {
        return dedent `
      Model: ${data.useModelInput ? '(Using Input)' : data.model}
    `;
    },
    async process(data, inputData, context) {
        const accessToken = context.getPluginConfig('huggingFaceAccessToken');
        const prompt = coerceType(inputData['prompt'], 'string');
        const endpoint = getInputOrData(data, inputData, 'endpoint');
        const model = getInputOrData(data, inputData, 'model');
        const width = getInputOrData(data, inputData, 'width', 'number');
        const height = getInputOrData(data, inputData, 'height', 'number');
        const negativePrompt = getInputOrData(data, inputData, 'negativePrompt') || undefined;
        const guidanceScale = getInputOrData(data, inputData, 'guidanceScale', 'number');
        const numInferenceSteps = getInputOrData(data, inputData, 'numInferenceSteps', 'number');
        const hf = endpoint ? new HfInferenceEndpoint(endpoint, accessToken) : new HfInference(accessToken);
        const image = await hf.textToImage({
            inputs: prompt,
            model,
            parameters: {
                width,
                height,
                negative_prompt: negativePrompt,
                guidance_scale: guidanceScale,
                num_inference_steps: numInferenceSteps,
            },
        });
        return {
            ['output']: {
                type: 'image',
                value: {
                    mediaType: 'image/png',
                    data: new Uint8Array(await image.arrayBuffer()),
                },
            },
        };
    },
};
export const textToImageHuggingFaceNode = pluginNodeDefinition(TextToImageHuggingFaceNodeImpl, 'Text-to-Image (Hugging Face)');
