import { nanoid } from 'nanoid/non-secure';
import { dedent } from 'ts-dedent';
import { Battle, ClosedQA, Factuality, Humor, Possible, Security, Summary, Translation, Sql, } from 'autoevals';
import { match } from 'ts-pattern';
import { coerceType } from '../../utils/coerceType.js';
import { pluginNodeDefinition } from '../../model/NodeDefinition.js';
const options = [
    { label: 'Factuality', value: 'factuality' },
    { label: 'Humor', value: 'humor' },
    { label: 'Security', value: 'security' },
    { label: 'Possible', value: 'possible' },
    { label: 'Summary', value: 'summary' },
    { label: 'Translation', value: 'translation' },
    { label: 'Battle', value: 'battle' },
    { label: 'Closed Q&A', value: 'closed_q_a' },
    { label: 'SQL', value: 'sql' },
];
export const AutoEvalsNodeImpl = {
    create() {
        const chartNode = {
            type: 'autoevals',
            title: 'Autoevals',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 250,
            },
            data: {
                evaluatorName: 'factuality',
            },
        };
        return chartNode;
    },
    getInputDefinitions(data) {
        const base = [
            {
                id: 'output',
                dataType: 'string',
                title: 'Output',
            },
            {
                id: 'expected',
                dataType: 'string',
                title: 'Expected',
            },
        ];
        const forEvaluator = match(data.evaluatorName)
            .with('factuality', () => [
            {
                id: 'input',
                dataType: 'string',
                title: 'Input',
            },
        ])
            .with('battle', () => [
            {
                id: 'instructions',
                dataType: 'string',
                title: 'Instructions',
            },
        ])
            .with('closed_q_a', () => [
            {
                id: 'input',
                dataType: 'string',
                title: 'Input',
            },
            {
                id: 'criteria',
                dataType: 'string',
                title: 'Criteria',
            },
        ])
            .with('humor', () => [])
            .with('possible', () => [
            {
                id: 'input',
                dataType: 'string',
                title: 'Input',
            },
        ])
            .with('security', () => [])
            .with('summary', () => [
            {
                id: 'input',
                dataType: 'string',
                title: 'Input',
            },
        ])
            .with('translation', () => [
            {
                id: 'input',
                dataType: 'string',
                title: 'Input',
            },
            {
                id: 'language',
                dataType: 'string',
                title: 'Language',
            },
        ])
            .with('sql', () => [
            {
                id: 'input',
                dataType: 'string',
                title: 'Input',
            },
        ])
            .with(undefined, () => [])
            .exhaustive();
        return [...forEvaluator, ...base];
    },
    getOutputDefinitions() {
        return [
            {
                dataType: 'number',
                id: 'score',
                title: 'Score',
            },
            {
                dataType: 'string',
                id: 'rationale',
                title: 'Rationale',
            },
            {
                dataType: 'object',
                id: 'metadata',
                title: 'Metadata',
            },
        ];
    },
    getEditors() {
        return [
            {
                type: 'dropdown',
                dataKey: 'evaluatorName',
                label: 'Evaluator',
                options,
            },
        ];
    },
    getBody(data) {
        return options.find((option) => option.value === data.evaluatorName)?.label ?? 'None';
    },
    getUIData() {
        return {
            infoBoxBody: dedent `
        Evaluates the validity of a response using the autoevals library.
      `,
            infoBoxTitle: 'Autoevals Node',
            contextMenuTitle: 'Autoevals',
            group: 'Custom',
        };
    },
    async process(data, inputs, context) {
        const evaluatorName = data.evaluatorName;
        const output = coerceType(inputs['output'], 'string');
        const expected = coerceType(inputs['expected'], 'string');
        const baseArgs = {
            output,
            expected,
            openAiApiKey: context.settings.openAiKey,
            openAiOrganizationId: context.settings.openAiOrganization,
        };
        const result = await match(evaluatorName)
            .with('factuality', () => {
            const input = coerceType(inputs['input'], 'string');
            return Factuality({ ...baseArgs, input });
        })
            .with('battle', () => {
            const instructions = coerceType(inputs['instructions'], 'string');
            return Battle({ ...baseArgs, instructions });
        })
            .with('closed_q_a', () => {
            const input = coerceType(inputs['input'], 'string');
            const criteria = coerceType(inputs['criteria'], 'string');
            return ClosedQA({ ...baseArgs, input, criteria });
        })
            .with('humor', () => {
            return Humor({ ...baseArgs });
        })
            .with('possible', () => {
            const input = coerceType(inputs['input'], 'string');
            return Possible({ ...baseArgs, input });
        })
            .with('security', () => {
            return Security({ ...baseArgs });
        })
            .with('summary', () => {
            const input = coerceType(inputs['input'], 'string');
            return Summary({ ...baseArgs, input });
        })
            .with('translation', () => {
            const input = coerceType(inputs['input'], 'string');
            const language = coerceType(inputs['language'], 'string');
            return Translation({ ...baseArgs, input, language });
        })
            .with('sql', () => {
            const input = coerceType(inputs['input'], 'string');
            return Sql({ ...baseArgs, input });
        })
            .with(undefined, () => {
            throw new Error('Evaluator name is undefined');
        })
            .exhaustive();
        return {
            ['score']: {
                type: 'number',
                value: result.score,
            },
            ['rationale']: {
                type: 'string',
                value: result.metadata?.rationale ?? '',
            },
            ['metadata']: {
                type: 'object',
                value: result.metadata,
            },
        };
    },
};
export const autoEvalsNode = pluginNodeDefinition(AutoEvalsNodeImpl, 'Autoevals');
