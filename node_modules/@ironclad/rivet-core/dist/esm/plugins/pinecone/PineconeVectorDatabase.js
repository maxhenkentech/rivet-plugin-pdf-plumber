import {} from '../../index.js';
import * as CryptoJS from 'crypto-js';
import { coerceType } from '../../utils/coerceType.js';
export class PineconeVectorDatabase {
    #apiKey;
    constructor(settings) {
        this.#apiKey = settings.pluginSettings?.pinecone?.pineconeApiKey;
    }
    async store(collection, vector, data, { id }) {
        const collectionDetails = getCollection(coerceType(collection, 'string'));
        if (!id) {
            id = CryptoJS.SHA256(vector.value.join(',')).toString(CryptoJS.enc.Hex);
        }
        const response = await fetch(`${collectionDetails.host}/vectors/upsert`, {
            method: 'POST',
            body: JSON.stringify({
                vectors: [
                    {
                        id,
                        values: vector.value,
                        metadata: {
                            data: data.value,
                        },
                    },
                ],
                ...collectionDetails.options,
            }),
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
                'api-key': this.#apiKey,
            },
        });
        if (response.status !== 200) {
            throw new Error(`Pinecone error: ${await response.text()}`);
        }
    }
    async nearestNeighbors(collection, vector, k) {
        const collectionDetails = getCollection(coerceType(collection, 'string'));
        const response = await fetch(`${collectionDetails.host}/query`, {
            method: 'POST',
            body: JSON.stringify({
                vector: vector.value,
                topK: k,
                includeMetadata: true,
                ...collectionDetails.options,
            }),
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
                'api-key': this.#apiKey,
            },
        });
        if (response.status !== 200) {
            throw new Error(`Pinecone error: ${await response.text()}`);
        }
        const responseData = await response.json();
        const { matches } = responseData;
        return {
            type: 'object[]',
            value: matches.map(({ id, metadata }) => ({ id, data: metadata.data, metadata })),
        };
    }
}
function getCollection(collectionString) {
    let collectionURL;
    if (!collectionString.startsWith('http://') && !collectionString.startsWith('https://')) {
        collectionString = `https://${collectionString}`;
    }
    try {
        collectionURL = new URL(collectionString);
    }
    catch (error) {
        throw new Error(`Incorrectly formatted Pinecone collection: ${error}`);
    }
    const host = `${collectionURL.protocol}//${collectionURL.host}`;
    const options = {};
    if (collectionURL.pathname !== '/') {
        // Chop off the leading slash.
        options.namespace = collectionURL.pathname.slice(1);
    }
    return { host, options };
}
