import { NodeImpl } from '../NodeImpl.js';
import { nanoid } from 'nanoid/non-secure';
import { dedent } from 'ts-dedent';
import { nodeDefinition } from '../NodeDefinition.js';
import { getInputOrData, coerceTypeOptional, newId, coerceType } from '../../utils/index.js';
import { arrayizeDataValue, unwrapDataValue } from '../DataValue.js';
export class AppendToDatasetNodeImpl extends NodeImpl {
    static create() {
        return {
            id: nanoid(),
            type: 'appendToDataset',
            title: 'Append to Dataset',
            visualData: { x: 0, y: 0, width: 250 },
            data: {
                datasetId: '',
            },
        };
    }
    getInputDefinitions() {
        const inputDefinitions = [];
        inputDefinitions.push({
            id: 'data',
            dataType: 'string[]',
            title: 'Data',
            description: 'The data to append to the dataset. May be a string or array of strings. If an array, each element will be a column in the dataset.',
        });
        inputDefinitions.push({
            id: 'id',
            dataType: 'string',
            title: 'ID',
            description: 'The ID of the row to append. If not provided, a random ID will be generated. If an existing ID is provided, the row will be overwritten.',
        });
        inputDefinitions.push({
            id: 'embedding',
            dataType: 'vector',
            title: 'Embedding',
            description: 'The vector embedding to store with the row.',
        });
        if (this.data.useDatasetIdInput) {
            inputDefinitions.push({
                id: 'datasetId',
                title: 'Dataset ID',
                dataType: 'string',
                description: 'The ID of the dataset to append to.',
            });
        }
        return inputDefinitions;
    }
    getOutputDefinitions() {
        return [
            {
                id: 'dataset',
                title: 'Dataset',
                dataType: 'object', // technically string[][]...
            },
            {
                id: 'id_out',
                title: 'ID',
                dataType: 'string',
            },
        ];
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Appends a row of data to the specified dataset.
      `,
            infoBoxTitle: 'Append to Dataset Node',
            contextMenuTitle: 'Append to Dataset',
            group: ['Input/Output'],
        };
    }
    getEditors() {
        return [
            {
                type: 'datasetSelector',
                label: 'Dataset',
                dataKey: 'datasetId',
                useInputToggleDataKey: 'useDatasetIdInput',
            },
        ];
    }
    async process(inputs, context) {
        const { datasetProvider } = context;
        if (datasetProvider == null) {
            throw new Error('datasetProvider is required');
        }
        const datasetId = getInputOrData(this.data, inputs, 'datasetId', 'string');
        const dataId = coerceTypeOptional(inputs['id'], 'string') || newId();
        const embedding = coerceTypeOptional(inputs['embedding'], 'vector');
        const dataInput = inputs['data'];
        if (!dataInput) {
            throw new Error('data input is required');
        }
        const data = arrayizeDataValue(unwrapDataValue(dataInput));
        const stringData = data.map((d) => coerceType(d, 'string'));
        const newData = {
            id: dataId,
            data: stringData,
            embedding,
        };
        await datasetProvider.putDatasetRow(datasetId, newData);
        return {
            ['dataset']: {
                type: 'object',
                value: newData,
            },
            ['id_out']: {
                type: 'string',
                value: datasetId,
            },
        };
    }
}
export const appendToDatasetNode = nodeDefinition(AppendToDatasetNodeImpl, 'Append To Dataset');
