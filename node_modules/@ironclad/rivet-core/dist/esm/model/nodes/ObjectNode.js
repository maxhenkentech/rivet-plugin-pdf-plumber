import {} from '../NodeBase.js';
import { nanoid } from 'nanoid/non-secure';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import {} from '../DataValue.js';
import { dedent } from 'ts-dedent';
import {} from '../EditorDefinition.js';
const DEFAULT_JSON_TEMPLATE = `{
  "key": "{{input}}"
}`;
export class ObjectNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'object',
            title: 'Object',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 200,
            },
            data: {
                jsonTemplate: DEFAULT_JSON_TEMPLATE,
            },
        };
        return chartNode;
    }
    getInputDefinitions(connections) {
        // Extract inputs from text, everything like {{input}}
        const inputNames = [...new Set(this.chartNode.data.jsonTemplate.match(/\{\{([^}]+)\}\}/g))];
        return (inputNames?.map((inputName) => {
            return {
                // id and title should not have the {{ and }}
                id: inputName.slice(2, -2),
                title: inputName.slice(2, -2),
                dataType: 'any',
                required: false,
            };
        }) ?? []);
    }
    getOutputDefinitions() {
        return [
            {
                dataType: 'object',
                id: 'output',
                title: 'Output',
            },
        ];
    }
    getEditors() {
        return [
            {
                type: 'code',
                label: 'JSON Template',
                dataKey: 'jsonTemplate',
                language: 'json',
                theme: 'prompt-interpolation',
            },
        ];
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Creates an object from input values and a JSON template, escaping the input values and inserting them into the template.

        Use double-quotes around the input values to escape them. String values are automatically escaped.

        Useful for creating objects from multiple inputs.
      `,
            infoBoxTitle: 'Object Node',
            contextMenuTitle: 'Object',
            group: ['Objects'],
        };
    }
    interpolate(baseString, values) {
        return baseString.replace(/("?)\{\{([^}]+)\}\}("?)/g, (_m, openQuote, key, _closeQuote) => {
            const isQuoted = Boolean(openQuote);
            const value = values[key];
            if (value == null) {
                return 'null';
            }
            if (isQuoted && typeof value === 'string') {
                // Adds double-quotes back.
                return JSON.stringify(value);
            }
            if (isQuoted) {
                // Non-strings require a double-stringify, first to turn them into a string, then to escape that string and add quotes.
                return JSON.stringify(JSON.stringify(value));
            }
            // Otherwise, it was not quoted, so no need to double-stringify
            return JSON.stringify(value);
        });
    }
    async process(inputs) {
        const inputMap = Object.keys(inputs).reduce((acc, key) => {
            acc[key] = inputs[key]?.value;
            return acc;
        }, {});
        const outputValue = JSON.parse(this.interpolate(this.chartNode.data.jsonTemplate, inputMap));
        return {
            output: {
                type: 'object',
                value: outputValue,
            },
        };
    }
}
export const objectNode = nodeDefinition(ObjectNodeImpl, 'Object');
