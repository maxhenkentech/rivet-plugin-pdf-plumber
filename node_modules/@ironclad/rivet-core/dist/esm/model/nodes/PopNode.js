import {} from '../NodeBase.js';
import { nanoid } from 'nanoid/non-secure';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import {} from '../GraphProcessor.js';
import { dedent } from 'ts-dedent';
export class PopNodeImpl extends NodeImpl {
    static create() {
        const baseNode = {
            type: 'pop',
            title: 'Pop',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 200,
            },
            data: {},
        };
        return baseNode;
    }
    getInputDefinitions() {
        return [
            {
                dataType: 'any[]',
                id: 'array',
                title: 'Array',
                coerced: false,
            },
        ];
    }
    getOutputDefinitions() {
        return [
            {
                dataType: 'any',
                id: 'lastItem',
                title: this.data.fromFront ? 'First' : 'Last',
            },
            {
                dataType: 'any',
                id: 'restOfArray',
                title: 'Rest',
            },
        ];
    }
    getEditors(_context) {
        return [
            {
                label: 'Pop from front',
                type: 'toggle',
                dataKey: 'fromFront',
            },
        ];
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Pops the last value off the input array and outputs the new array and the popped value.

        Can also be used to just extract the last value from an array.
      `,
            infoBoxTitle: 'Pop Node',
            contextMenuTitle: 'Pop',
            group: ['Lists'],
        };
    }
    getBody(_context) {
        return this.data.fromFront ? 'From front' : 'From back';
    }
    async process(inputs) {
        const inputArray = inputs['array']?.value;
        if (!Array.isArray(inputArray) || inputArray.length === 0) {
            throw new Error('Input array is empty or not an array');
        }
        const lastItem = this.data.fromFront ? inputArray[0] : inputArray[inputArray.length - 1];
        const rest = this.data.fromFront ? inputArray.slice(1) : inputArray.slice(0, inputArray.length - 1);
        return {
            ['lastItem']: {
                type: 'any',
                value: lastItem,
            },
            ['restOfArray']: {
                type: 'any[]',
                value: rest,
            },
        };
    }
}
export const popNode = nodeDefinition(PopNodeImpl, 'Pop');
