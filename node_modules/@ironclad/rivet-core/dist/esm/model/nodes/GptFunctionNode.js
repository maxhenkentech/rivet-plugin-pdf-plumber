import {} from '../NodeBase.js';
import { nanoid } from 'nanoid/non-secure';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import { dedent } from 'ts-dedent';
import {} from '../EditorDefinition.js';
import {} from '../NodeBodySpec.js';
import { interpolate } from '../../utils/interpolation.js';
import { keys } from '../../utils/typeSafety.js';
import { coerceTypeOptional, coerceType } from '../../utils/coerceType.js';
import { getInputOrData } from '../../utils/index.js';
export class GptFunctionNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'gptFunction',
            title: 'GPT Function',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 250,
            },
            data: {
                name: 'newFunction',
                description: 'No description provided',
                schema: dedent `
          {
            "type": "object",
            "properties": {}
          }`,
            },
        };
        return chartNode;
    }
    getInputDefinitions() {
        let inputs = [];
        if (this.data.useNameInput) {
            inputs.push({
                id: 'name',
                title: 'Name',
                dataType: 'string',
                description: 'The name of the function that GPT will see as available to call',
            });
        }
        if (this.data.useDescriptionInput) {
            inputs.push({
                id: 'description',
                title: 'Description',
                dataType: 'string',
                description: 'The description of the function that GPT will see as available to call',
            });
        }
        if (this.data.useSchemaInput) {
            inputs.push({
                id: 'schema',
                title: 'Schema',
                dataType: 'object',
                description: 'The schema of the function that GPT will see as available to call',
            });
        }
        // Extract inputs from promptText, everything like {{input}}
        const inputNames = this.data.useSchemaInput ? [] : [...new Set(this.data.schema.match(/\{\{([^}]+)\}\}/g))];
        inputs = [
            ...inputs,
            ...(inputNames?.map((inputName) => {
                const name = inputName.slice(2, -2);
                return {
                    // id and title should not have the {{ and }}
                    id: `input-${name}`,
                    title: name,
                    dataType: 'string',
                    description: `An interpolated value in the schema named '${name}'`,
                };
            }) ?? []),
        ];
        return inputs;
    }
    getOutputDefinitions() {
        return [
            {
                id: 'function',
                title: 'Function',
                dataType: 'gpt-function',
                description: 'The GPT function that can be called by the LLM.',
            },
        ];
    }
    getEditors() {
        return [
            {
                type: 'string',
                label: 'Name',
                dataKey: 'name',
                useInputToggleDataKey: 'useNameInput',
            },
            {
                type: 'string',
                label: 'Description',
                dataKey: 'description',
                useInputToggleDataKey: 'useDescriptionInput',
            },
            {
                type: 'code',
                label: 'Schema',
                dataKey: 'schema',
                language: 'json',
                useInputToggleDataKey: 'useSchemaInput',
            },
        ];
    }
    getBody() {
        return `!markdown_${this.data.name}_: ${this.data.description}`;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Defines a GPT function, which is a method that the LLM can call in its responses.
      `,
            infoBoxTitle: 'GPT Function Node',
            contextMenuTitle: 'GPT Function',
            group: ['AI'],
        };
    }
    async process(inputs) {
        const name = getInputOrData(this.data, inputs, 'name');
        const description = getInputOrData(this.data, inputs, 'description');
        let schema;
        if (this.data.useSchemaInput) {
            schema = coerceType(inputs['schema'], 'object');
        }
        else {
            const inputMap = keys(inputs)
                .filter((key) => key.startsWith('input'))
                .reduce((acc, key) => {
                const stringValue = coerceTypeOptional(inputs[key], 'string') ?? '';
                const interpolationKey = key.slice('input-'.length);
                acc[interpolationKey] = stringValue;
                return acc;
            }, {});
            const interpolated = interpolate(this.data.schema, inputMap);
            schema = JSON.parse(interpolated);
        }
        return {
            ['function']: {
                type: 'gpt-function',
                value: {
                    name,
                    description,
                    parameters: schema,
                },
            },
        };
    }
}
export const gptFunctionNode = nodeDefinition(GptFunctionNodeImpl, 'GPT Function');
