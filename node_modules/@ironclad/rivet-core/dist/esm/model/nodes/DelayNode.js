import {} from '../NodeBase.js';
import { nanoid } from 'nanoid/non-secure';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import {} from '../GraphProcessor.js';
import {} from '../../index.js';
import { dedent } from 'ts-dedent';
import { getInputOrData } from '../../utils/inputs.js';
export class DelayNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'delay',
            title: 'Delay',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 175,
            },
            data: {
                delay: 0,
            },
        };
        return chartNode;
    }
    getInputDefinitions(connections) {
        const inputs = [];
        const inputCount = this.#getInputPortCount(connections);
        if (this.data.useDelayInput) {
            inputs.push({
                dataType: 'number',
                id: 'delay',
                title: 'Delay (ms)',
            });
        }
        for (let i = 1; i <= inputCount; i++) {
            inputs.push({
                dataType: 'any',
                id: `input${i}`,
                title: `Input ${i}`,
            });
        }
        return inputs;
    }
    getOutputDefinitions(connections) {
        const outputs = [];
        const inputCount = this.#getInputPortCount(connections);
        for (let i = 1; i <= inputCount - 1; i++) {
            outputs.push({
                dataType: 'any',
                id: `output${i}`,
                title: `Output ${i}`,
            });
        }
        return outputs;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Delays the execution and then passes the input value to the output without any modifications.
      `,
            infoBoxTitle: 'Delay Node',
            contextMenuTitle: 'Delay',
            group: ['Logic'],
        };
    }
    #getInputPortCount(connections) {
        const inputNodeId = this.chartNode.id;
        const inputConnections = connections.filter((connection) => connection.inputNodeId === inputNodeId && connection.inputId.startsWith('input'));
        let maxInputNumber = 0;
        for (const connection of inputConnections) {
            const messageNumber = parseInt(connection.inputId.replace('input', ''), 10);
            if (messageNumber > maxInputNumber) {
                maxInputNumber = messageNumber;
            }
        }
        return maxInputNumber + 1;
    }
    getEditors() {
        return [
            {
                type: 'number',
                label: 'Delay (ms)',
                dataKey: 'delay',
                useInputToggleDataKey: 'useDelayInput',
                defaultValue: 0,
            },
        ];
    }
    getBody() {
        return `Delay ${this.data.useDelayInput ? '(Input ms)' : `${this.chartNode.data.delay}ms`}`;
    }
    async process(inputData) {
        const delayAmount = getInputOrData(this.data, inputData, 'delay', 'number');
        await new Promise((resolve) => setTimeout(resolve, delayAmount));
        const inputCount = Object.keys(inputData).filter((key) => key.startsWith('input')).length;
        const outputs = {};
        for (let i = 1; i <= inputCount; i++) {
            const input = inputData[`input${i}`];
            outputs[`output${i}`] = input;
        }
        return outputs;
    }
}
export const delayNode = nodeDefinition(DelayNodeImpl, 'Delay');
