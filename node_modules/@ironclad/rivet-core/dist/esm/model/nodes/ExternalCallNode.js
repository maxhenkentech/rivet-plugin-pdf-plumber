import {} from '../NodeBase.js';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import {} from '../DataValue.js';
import { nanoid } from 'nanoid/non-secure';
import {} from '../GraphProcessor.js';
import { coerceType } from '../../utils/coerceType.js';
import { getError } from '../../utils/errors.js';
import {} from '../ProcessContext.js';
import { omit } from 'lodash-es';
import { dedent } from 'ts-dedent';
import {} from '../EditorDefinition.js';
import {} from '../NodeBodySpec.js';
export class ExternalCallNodeImpl extends NodeImpl {
    static create() {
        return {
            id: nanoid(),
            type: 'externalCall',
            title: 'External Call',
            visualData: { x: 0, y: 0, width: 150 },
            data: {
                functionName: '',
                useFunctionNameInput: false,
                useErrorOutput: false,
            },
        };
    }
    getInputDefinitions() {
        const inputDefinitions = [];
        if (this.chartNode.data.useFunctionNameInput) {
            inputDefinitions.push({
                id: 'functionName',
                title: 'Function Name',
                dataType: 'string',
            });
        }
        inputDefinitions.push({
            id: 'arguments',
            title: 'Arguments',
            dataType: 'any[]',
        });
        return inputDefinitions;
    }
    getOutputDefinitions() {
        const outputs = [
            {
                id: 'result',
                title: 'Result',
                dataType: 'any',
            },
        ];
        if (this.chartNode.data.useErrorOutput) {
            outputs.push({
                id: 'error',
                title: 'Error',
                dataType: 'string',
            });
        }
        return outputs;
    }
    getEditors() {
        return [
            {
                type: 'string',
                label: 'Function Name',
                dataKey: 'functionName',
                useInputToggleDataKey: 'useFunctionNameInput',
            },
            {
                type: 'toggle',
                label: 'Use Error Output',
                dataKey: 'useErrorOutput',
            },
        ];
    }
    getBody() {
        return this.data.useFunctionNameInput ? '(Using Input)' : this.data.functionName;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Provides a way to call into the host project from inside a Rivet graph when Rivet graphs are integrated into another project.
      `,
            infoBoxTitle: 'External Call Node',
            contextMenuTitle: 'External Call',
            group: ['Advanced'],
        };
    }
    async process(inputs, context) {
        const functionName = this.chartNode.data.useFunctionNameInput
            ? coerceType(inputs['functionName'], 'string')
            : this.chartNode.data.functionName;
        const args = inputs['arguments'];
        let arrayArgs = {
            type: 'any[]',
            value: [],
        };
        if (args) {
            if (args.type.endsWith('[]') === false) {
                arrayArgs = {
                    type: 'any[]',
                    value: [args.value],
                };
            }
            else {
                arrayArgs = args;
            }
        }
        const fn = context.externalFunctions[functionName];
        const externalContext = omit(context, ['setGlobal']);
        if (!fn) {
            if (this.data.useErrorOutput) {
                return {
                    ['result']: {
                        type: 'control-flow-excluded',
                        value: undefined,
                    },
                    ['error']: {
                        type: 'string',
                        value: `Function ${functionName} not was not defined using setExternalCall`,
                    },
                };
            }
            else {
                throw new Error(`Function ${functionName} not was not defined using setExternalCall`);
            }
        }
        if (this.data.useErrorOutput) {
            try {
                const result = await fn(externalContext, ...arrayArgs.value);
                return {
                    ['result']: result,
                    ['cost']: {
                        type: 'number',
                        value: result.cost ?? 0,
                    },
                    ['error']: {
                        type: 'control-flow-excluded',
                        value: undefined,
                    },
                };
            }
            catch (error) {
                return {
                    ['result']: {
                        type: 'control-flow-excluded',
                        value: undefined,
                    },
                    ['error']: {
                        type: 'string',
                        value: getError(error).message,
                    },
                };
            }
        }
        const result = await fn(externalContext, ...arrayArgs.value);
        return {
            ['result']: result,
        };
    }
}
export const externalCallNode = nodeDefinition(ExternalCallNodeImpl, 'External Call');
