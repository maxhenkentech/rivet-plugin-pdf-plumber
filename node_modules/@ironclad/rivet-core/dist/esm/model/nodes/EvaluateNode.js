import {} from '../NodeBase.js';
import { nanoid } from 'nanoid/non-secure';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import {} from '../GraphProcessor.js';
import {} from '../../index.js';
import { match } from 'ts-pattern';
import { dedent } from 'ts-dedent';
import { coerceType, coerceTypeOptional } from '../../utils/coerceType.js';
const unaryOperation = ['abs', 'negate'];
const isUnaryOp = (operation) => unaryOperation.includes(operation);
export class EvaluateNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'evaluate',
            title: 'Evaluate',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 175,
            },
            data: {
                operation: '+',
            },
        };
        return chartNode;
    }
    getInputDefinitions() {
        const inputs = [
            {
                dataType: 'number',
                id: 'a',
                title: 'A',
            },
        ];
        const isUnary = !this.data.useOperationInput && isUnaryOp(this.data.operation);
        if (!isUnary) {
            inputs.push({
                dataType: 'number',
                id: 'b',
                title: 'B',
            });
        }
        if (this.data.useOperationInput) {
            inputs.push({
                dataType: 'string',
                id: 'operation',
                title: 'Operation',
            });
        }
        return inputs;
    }
    getOutputDefinitions() {
        return [
            {
                dataType: 'number',
                id: 'output',
                title: 'Output',
            },
        ];
    }
    getEditors() {
        return [
            {
                type: 'dropdown',
                label: 'Operation',
                dataKey: 'operation',
                options: [
                    { label: '+', value: '+' },
                    { label: '-', value: '-' },
                    { label: '*', value: '*' },
                    { label: '/', value: '/' },
                    { label: '^', value: '^' },
                    { label: '%', value: '%' },
                    { label: 'abs', value: 'abs' },
                    { label: 'negate', value: 'negate' },
                ],
                useInputToggleDataKey: 'useOperationInput',
            },
        ];
    }
    getBody() {
        const isUnary = !this.data.useOperationInput && isUnaryOp(this.data.operation);
        if (isUnary) {
            return match(this.data.operation)
                .with('abs', () => 'abs(A)')
                .with('negate', () => '-A')
                .exhaustive();
        }
        if (this.data.operation === '^') {
            return '!markdownA<sup>B</sup>';
        }
        return this.data.useOperationInput ? 'A (Operation) B' : `A ${this.data.operation} B`;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Evaluates the configured mathematical operation on the input values and outputs the result.

        For more complex operations, you should use the \`Code\` node.
      `,
            infoBoxTitle: 'Evaluate Node',
            contextMenuTitle: 'Evaluate',
            group: ['Numbers'],
        };
    }
    async process(inputs) {
        const operation = (this.data.useOperationInput ? coerceType(inputs['operation'], 'string') : this.data.operation);
        const inputA = coerceTypeOptional(inputs['a'], 'number');
        const inputB = coerceTypeOptional(inputs['b'], 'number');
        if (isUnaryOp(operation) && inputA) {
            return {
                ['output']: {
                    type: 'number',
                    value: match(operation)
                        .with('abs', () => Math.abs(inputA))
                        .with('negate', () => -inputA)
                        .exhaustive(),
                },
            };
        }
        if (inputA == null || inputB == null) {
            throw new Error('Missing input');
        }
        return {
            ['output']: {
                type: 'number',
                value: match(operation)
                    .with('+', () => inputA + inputB)
                    .with('-', () => inputA - inputB)
                    .with('*', () => inputA * inputB)
                    .with('/', () => inputA / inputB)
                    .with('^', () => Math.pow(inputA, inputB))
                    .with('%', () => inputA % inputB)
                    .exhaustive(),
            },
        };
    }
}
export const evaluateNode = nodeDefinition(EvaluateNodeImpl, 'Evaluate');
