import {} from '../NodeBase.js';
import { nanoid } from 'nanoid/non-secure';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import {} from '../DataValue.js';
import {} from '../GraphProcessor.js';
import {} from '../ProcessContext.js';
import { ControlFlowExcludedPort } from '../../utils/symbols.js';
import { dedent } from 'ts-dedent';
import {} from '../EditorDefinition.js';
import {} from '../NodeBodySpec.js';
export class GraphOutputNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'graphOutput',
            title: 'Graph Output',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 300,
            },
            data: {
                id: 'output',
                dataType: 'string',
            },
        };
        return chartNode;
    }
    getInputDefinitions() {
        return [
            {
                id: 'value',
                title: this.data.id,
                dataType: this.chartNode.data.dataType,
            },
        ];
    }
    getOutputDefinitions() {
        return [
            {
                id: 'valueOutput',
                title: this.data.id,
                dataType: this.chartNode.data.dataType,
            },
        ];
    }
    getEditors() {
        return [
            {
                type: 'string',
                label: 'ID',
                dataKey: 'id',
            },
            {
                type: 'dataTypeSelector',
                label: 'Data Type',
                dataKey: 'dataType',
            },
        ];
    }
    getBody() {
        return dedent `
      ${this.data.id}
      Type: ${this.data.dataType}
    `;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Each instance of this node represents an individual output of the graph. The value passed into this node becomes part of the overall output of the graph.
      `,
            infoBoxTitle: 'Graph Output Node',
            contextMenuTitle: 'Graph Output',
            group: ['Input/Output'],
        };
    }
    async process(inputs, context) {
        const value = inputs['value'] ?? { type: 'any', value: undefined };
        const isExcluded = value.type === 'control-flow-excluded' || inputs[ControlFlowExcludedPort] != null;
        if (isExcluded && context.graphOutputs[this.data.id] == null) {
            context.graphOutputs[this.data.id] = {
                type: 'control-flow-excluded',
                value: undefined,
            };
        }
        else if ((context.graphOutputs[this.data.id] == null ||
            context.graphOutputs[this.data.id]?.type === 'control-flow-excluded') &&
            inputs['value']) {
            context.graphOutputs[this.data.id] = value;
        }
        if (isExcluded) {
            return {
                ['valueOutput']: {
                    type: 'control-flow-excluded',
                    value: undefined,
                },
            };
        }
        return {
            ['valueOutput']: context.graphOutputs[this.data.id],
        };
    }
}
export const graphOutputNode = nodeDefinition(GraphOutputNodeImpl, 'Graph Output');
